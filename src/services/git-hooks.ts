/**
 * Git Hooks Service
 * Manages git hooks installation and configuration for translation workflow
 */

import * as fs from 'fs';
import * as path from 'path';

export type HookType = 'pre-commit' | 'pre-push';

export interface HookStatus {
  [key: string]: boolean;
}

export class GitHooksService {
  private hooksDir: string;

  constructor(gitDir: string) {
    if (!fs.existsSync(gitDir)) {
      throw new Error('Git directory not found: ' + gitDir);
    }

    this.hooksDir = path.join(gitDir, 'hooks');
  }

  /**
   * Install a git hook
   */
  install(hookType: HookType): void {
    this.validateHookType(hookType);

    const hookPath = this.getHookPath(hookType);
    const hookContent = this.generateHookContent(hookType);

    // Create hooks directory if it doesn't exist
    if (!fs.existsSync(this.hooksDir)) {
      fs.mkdirSync(this.hooksDir, { recursive: true });
    }

    // Backup existing hook if it exists and is not a DeepL hook
    if (fs.existsSync(hookPath)) {
      const existingContent = fs.readFileSync(hookPath, 'utf-8');
      if (!this.isDeepLHook(existingContent)) {
        const backupPath = hookPath + '.backup';
        fs.copyFileSync(hookPath, backupPath);
      }
    }

    // Write the hook file
    fs.writeFileSync(hookPath, hookContent, 'utf-8');

    // Make it executable
    fs.chmodSync(hookPath, 0o755);
  }

  /**
   * Uninstall a git hook
   */
  uninstall(hookType: HookType): void {
    this.validateHookType(hookType);

    const hookPath = this.getHookPath(hookType);

    if (!fs.existsSync(hookPath)) {
      return;
    }

    // Verify it's a DeepL hook before removing
    const content = fs.readFileSync(hookPath, 'utf-8');
    if (!this.isDeepLHook(content)) {
      throw new Error('Hook is not a DeepL CLI hook. Remove it manually if needed.');
    }

    // Remove the hook
    fs.unlinkSync(hookPath);

    // Restore backup if it exists
    const backupPath = hookPath + '.backup';
    if (fs.existsSync(backupPath)) {
      fs.copyFileSync(backupPath, hookPath);
      fs.unlinkSync(backupPath);
    }
  }

  /**
   * Check if a hook is installed
   */
  isInstalled(hookType: HookType): boolean {
    this.validateHookType(hookType);

    const hookPath = this.getHookPath(hookType);

    if (!fs.existsSync(hookPath)) {
      return false;
    }

    const content = fs.readFileSync(hookPath, 'utf-8');
    return this.isDeepLHook(content);
  }

  /**
   * List all hooks and their installation status
   */
  list(): HookStatus {
    const hooks: HookType[] = ['pre-commit', 'pre-push'];
    const status: HookStatus = {};

    for (const hook of hooks) {
      status[hook] = this.isInstalled(hook);
    }

    return status;
  }

  /**
   * Get the full path to a hook file
   */
  getHookPath(hookType: HookType): string {
    this.validateHookType(hookType);
    return path.join(this.hooksDir, hookType);
  }

  /**
   * Find git root directory from current path
   */
  static findGitRoot(startPath?: string): string | null {
    let currentPath = startPath ?? process.cwd();

    // Traverse up the directory tree
    while (currentPath !== path.parse(currentPath).root) {
      const gitPath = path.join(currentPath, '.git');
      if (fs.existsSync(gitPath)) {
        return gitPath;
      }
      currentPath = path.dirname(currentPath);
    }

    return null;
  }

  /**
   * Generate hook script content
   */
  private generateHookContent(hookType: HookType): string {
    const commonHeader = `#!/bin/sh
# DeepL CLI Hook
# Generated by DeepL CLI - DO NOT EDIT MANUALLY
# To uninstall: deepl hooks uninstall ${hookType}

`;

    if (hookType === 'pre-commit') {
      return commonHeader + `# Pre-commit hook for DeepL CLI
# Validates that translation files are up-to-date

echo "üîç Checking translations..."

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Check if any translatable files are staged
TRANSLATABLE_FILES=$(echo "$STAGED_FILES" | grep -E '\\.(md|txt)$' || true)

if [ -z "$TRANSLATABLE_FILES" ]; then
  echo "‚úì No translatable files changed"
  exit 0
fi

# Check if translation files exist for staged files
# This is a basic check - you can customize it based on your workflow
echo "üìù Found translatable files:"
echo "$TRANSLATABLE_FILES"

# Optionally check if translations exist
# You can customize this based on your project structure
# For example, check if docs/README.md has docs/translations/README.es.md

echo "‚úì Translation check passed"
exit 0
`;
    } else if (hookType === 'pre-push') {
      return commonHeader + `# Pre-push hook for DeepL CLI
# Validates all translations before pushing

echo "üîç Validating all translations before push..."

# Check if deepl CLI is available
if ! command -v deepl &> /dev/null; then
  echo "‚ö†Ô∏è  DeepL CLI not found in PATH"
  echo "   Install: npm install -g deepl-cli"
  exit 0
fi

# You can add custom validation logic here
# For example:
# - Check if all .md files have corresponding translations
# - Validate translation files are not stale
# - Run translation validation command

echo "‚úì Translation validation passed"
exit 0
`;
    }

    throw new Error('Invalid hook type');
  }

  /**
   * Check if content is a DeepL CLI hook
   */
  private isDeepLHook(content: string): boolean {
    return content.includes('# DeepL CLI Hook');
  }

  /**
   * Validate hook type
   */
  private validateHookType(hookType: string): asserts hookType is HookType {
    if (hookType !== 'pre-commit' && hookType !== 'pre-push') {
      throw new Error(`Invalid hook type: ${hookType}. Must be 'pre-commit' or 'pre-push'`);
    }
  }
}
